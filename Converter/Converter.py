# -*- coding: utf-8 -*-
"""Untitled25.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TyEsIWwUKSXgXo2X4Cmsxbgt1PhEqOTY
"""

from google.colab import drive

drive.mount('/content/gdrive', force_remount=True)
root_path = 'gdrive/My Drive/SDA/'

inputs = open(root_path + 'input10P.txt', 'r').read().split('\n')
weight = open(root_path + 'weight2010MLP.txt', 'r').read().split('\n')
bias = open(root_path + 'bias2010MLP.txt', 'r').read().split('\n')

fileI = open(root_path + 'binInput2010MLP.txt', 'w')
fileW = open(root_path + 'binWeight2010MLP.txt', 'w')
fileB = open(root_path + 'binBias2010MLP.txt', 'w')

# four = float_to_fixed(6.25)
# two = float_to_fixed(0.52)

# Eight = four * two

# float_four = fixed_to_float(four,32)
# float_two = fixed_to_float(two,32)

# float_Eight = fixed_to_float(Eight, 64)
# float_Eight_32 = fixed_to_float(Eight)

# print('Fixed_Four: {}\tFloat_Four: {}\tBinary_Four: {}\t Len: {}'.format(four, float_four, bin(four), len(bin(four).split('b')[1])))
# print('Fixed_Two: {}\tFloat_Two: {}\tBinary_Two: {}\t Len: {}'.format(two, float_two, bin(two), len(bin(two).split('b')[1])))
# print('Fixed_Eight_32: {}\tFloat_Eight_32: {}\tBinary_Eight_32: {}\t Len: {}'.format(float_to_fixed(0.13), fixed_to_float(float_to_fixed(0.13),32), bin(float_to_fixed(0.13)), len(bin(float_to_fixed(0.13)).split('b')[1])))
# print('Fixed_Eight: {}\tFloat_Eight: {}\tBinary_Eight: {}\t Len: {}'.format(Eight, float_Eight, bin(Eight), len(bin(Eight).split('b')[1])))

for each_weight in weight[:-1]:
  fixed_point = float_to_fixed(float(each_weight))
  float_test = fixed_to_float(fixed_point)
  if fixed_point < 0:
    bin_number = bin(fixed_point & 0b1111111111111111111111111111111111111111).split('b')
  else:
    bin_number = bin(fixed_point).split('b')
    if len(bin_number[1]) != 40:
      bin_number[1] = ('0' * (40-len(bin_number[1]))) + bin_number[1]
  #print(each_weight + ': ' + str(fixed_point) + ': ' + str(float_test) + ': ' + bin_number[1])
  fileW.write(bin_number[1] + '\n')

for each_input in inputs[:-1]:
  fixed_point = float_to_fixed(float(each_input))
  float_test = fixed_to_float(fixed_point)
  #print(fixed_point)
  if fixed_point < 0:
    bin_number = bin(fixed_point & 0b1111111111111111111111111111111111111111).split('b')
  else:
    bin_number = bin(fixed_point).split('b')
    if len(bin_number[1]) != 40:
      bin_number[1] = ('0' * (40-len(bin_number[1]))) + bin_number[1]
  #print(each_input + ': ' + str(fixed_point) + ': ' + str(float_test) + ': ' + bin_number[1])
  fileI.write(bin_number[1] + '\n')

for each_bias in bias[:-1]:
  fixed_point = float_to_fixed(float(each_bias))
  float_test = fixed_to_float(fixed_point)
  #print(fixed_point)
  if fixed_point < 0:
    bin_number = bin(fixed_point & 0b1111111111111111111111111111111111111111).split('b')
  else:
    bin_number = bin(fixed_point).split('b')
    if len(bin_number[1]) != 40:
      bin_number[1] = ('0' * (40-len(bin_number[1]))) + bin_number[1]
  #print(each_bias + ': ' + str(fixed_point) + ': ' + str(float_test) + ': ' + bin_number[1])
  fileB.write(bin_number[1] + '\n')

fileI.close()
fileW.close()
fileB.close()

def float_to_fixed(number, bits = 32):
	return round(number * (1 << bits))

def fixed_to_float( number, bits = 32):
  return number / (1 << bits)

six_fixed = float_to_fixed(6.5)
six_number = fixed_to_float(six_fixed, 32)
six_bin = bin(six_fixed)

print('Number: {}\nFixed: {}\nBin: {}\tLen: {}'.format(six_fixed, six_number, six_bin, len(six_bin.split('b')[1])))

six_bin = six_bin.split('b')[1]
if len(six_bin) != 40:
  bits40 = ('0' * (40 - len(six_bin))) + six_bin
print('Bin_formated: {}\tLen: {}'.format(bits40, len(bits40)))

import random

testInputs = open(root_path + 'ArchitectureTestInputs.txt', 'w')
testWeights = open(root_path + 'ArchitectureTestWeights.txt', 'w')

testInputsReal = open(root_path + 'ArchitectureTestInputsRealValues.txt', 'w')
testWeightsReal = open(root_path + 'ArchitectureTestWeightsRealValues.txt', 'w')

for i in range(10):
  inputValue = random.uniform(-1,1)
  fixedValue = float_to_fixed(inputValue)
  testInputsReal.write(str(inputValue) + '\n')

  if fixedValue < 0:
    binValue = bin(fixedValue & 0b1111111111111111111111111111111111111111).split('b')[1]
  else:
    lenValue = len(bin(fixedValue).split('b')[1])
    if lenValue != 40:
      binValue = ('0' * (40 - lenValue)) + bin(fixedValue).split('b')[1]

  testInputs.write(binValue + '\n')

for i in range(100):
  weightsValue = random.uniform(-1,1)
  fixedValue = float_to_fixed(weightsValue)
  testWeightsReal.write(str(weightsValue) + '\n')

  if fixedValue < 0:
    binValue = bin(fixedValue & 0b1111111111111111111111111111111111111111).split('b')[1]
  else:
    lenValue = len(bin(fixedValue).split('b')[1])
    if lenValue != 40:
      binValue = ('0' * (40 - lenValue)) + bin(fixedValue).split('b')[1]

  testWeights.write(binValue + '\n')
  
testInputs.close()
testWeights.close()
testWeightsReal.close()
testInputsReal.close()

# testInputs = open(root_path + 'ArchitectureTestInputs.txt', 'r').read().split('\n')
# testWeights = open(root_path + 'ArchitectureTestWeights.txt', 'r').read().split('\n')

testInputsReal = open(root_path + 'input10P.txt', 'r').read().split('\n')
testWeightsReal = open(root_path + 'weight10P.txt', 'r').read().split('\n')
testBiasReal = open(root_path + 'bias10P.txt', 'r').read().split('\n')

result = 0
k = 0
for i in range(len(testInputsReal[:-1])):
  k = k + 1
  mulResult = float(testInputsReal[i]) * float(testWeightsReal[i])
  fixedMul = float_to_fixed(mulResult, 64)

  result = result + mulResult
  print('Multiplier between {} and {} equals to {}\t Fixed translation: {}'.format(testInputsReal[i], testWeightsReal[i], mulResult, fixedMul))

  print('Result: {}\tFixed translation: {}\t I: {}'.format(result, float_to_fixed(result, 32), k))


mulResult = float(testBiasReal[0]) * 1

print('Multiplier between {} and 1 equals to {}\t Fixed translation: {}'.format(testBiasReal[0], mulResult, float_to_fixed(mulResult)))

result = result + float(testBiasReal[0])

fixedResult = float_to_fixed(result)
if fixedResult < 0:
  binResult = bin(fixedResult & 0b1111111111111111111111111111111111111111)
else:
  if len(bin(fixedResult).split('b')[1]) != 40:
    binResult = ( '0' * (40 - len(bin(fixedResult).split('b')[1]))) + bin(fixedResult).split('b')[1]
print('Result: {}\tFixed translation: {}\tBin translation: {}'.format(result, float_to_fixed(result, 32), binResult))

test = bin(2697886713).split('b')[1]
print(test, len(test))

# testInputs = open(root_path + 'ArchitectureTestInputs.txt', 'r').read().split('\n')
# testWeights = open(root_path + 'ArchitectureTestWeights.txt', 'r').read().split('\n')

testInputsReal = open(root_path + 'input10P.txt', 'r').read().split('\n')
testWeightsReal = open(root_path + 'weight2010MLP.txt', 'r').read().split('\n')
testBiasReal = open(root_path + 'bias2010MLP.txt', 'r').read().split('\n')

result = 0
k = 0
# for i in range(len(testWeightsReal[:-1])):
#   print(testWeightsReal[i] + '\t' + str(i))
for i in range(len(testInputsReal[:-1])):
  k = k + 1
  mulResult = float(testInputsReal[i]) * float(testWeightsReal[i+1024])
  fixedMul = float_to_fixed(mulResult, 64)

  result = result + mulResult
  print('Multiplier between {} and {} equals to {}\t Fixed translation: {}'.format(testInputsReal[i], testWeightsReal[i+1024], mulResult, fixedMul))

  print('Result: {}\tFixed translation: {}\t I: {}'.format(result, float_to_fixed(result, 32), k))


mulResult = float(testBiasReal[1]) * 1

print('Multiplier between {} and 1 equals to {}\t Fixed translation: {}'.format(testBiasReal[0], mulResult, float_to_fixed(mulResult)))

result = result + float(testBiasReal[0])

fixedResult = float_to_fixed(result)
if fixedResult < 0:
  binResult = bin(fixedResult & 0b1111111111111111111111111111111111111111)
else:
  if len(bin(fixedResult).split('b')[1]) != 40:
    binResult = ( '0' * (40 - len(bin(fixedResult).split('b')[1]))) + bin(fixedResult).split('b')[1]
print('Result: {}\tFixed translation: {}\tBin translation: {}'.format(result, float_to_fixed(result, 32), binResult))